# starter-c
a tamper of c

## 树型结构

### 树和森林的转换
二叉树和树、森林之间是可以相互转换的。

树转换为一棵二叉树:

最左边孩子结点 -> 左子树结点
兄弟结点 -> 作为左边兄弟结点的右子树结点

![](/public/tree.png)

森林转换为一棵二叉树:

首先我们还是按照二叉树转换为树的规则，将森林中所有树转换为二叉树，接着我们只需要依次连接即可

![](/public/forest.png)

我们发现，相比树转换为二叉树，森林转换为二叉树之后，根节点就存在右子树了，右子树连接的都是森林中其他的树。

### 二叉树的性质
五个性质

1. 第i层最大结点数量 2^(i-1)
2. 深度k的树最大结点数量 n = 2^k - 1，边数E = n - 1
3. n0 = n2 + 1
4. n个结点的完全二叉树的深度k = [logn] + 1 （[logn]是以2为底求n的对数，并向下取整）
5. 对于一颗有n个结点的完全二叉树对于任意结点i
    - 如果有左右孩子，左孩子是2i，右孩子是2i+1
    - 如果i=1则是根结点；如果i>1，其父结点是[i/2]
    - 如果2i>n，则结点i没有左孩子
    - 如果2i+1>n，则结点i没有右孩子

### 红黑树的规则
1. 每个结点可以是黑色或是红色
2. 根结点一定是黑色
3. 红色结点的父结点和子结点不能为红色，也就是说不能有两个连续的红色
4. 所有空结点都是黑色（红黑树将空结点视为叶子结点）
5. 每个结点到空结点路径上出现的黑色结点个数都相等

插入时的判断：（插入时默认以红色结点插入）
- 如果整棵树为NULL，直接作为根结点，变成黑色。
- 如果父结点是黑色，直接插入就完事。
- 如果父结点为红色，且父结点的兄弟结点也是红色，直接变色即可（但是注意得继续往上看有没有破坏之前的结构）
- 如果父结点为红色，但父结点的兄弟结点为黑色，需要先根据情况（LL、RR、LR、RL）进行旋转，然后再变色。

### B树满足条件 m阶

> B树的搜索，顺序访问，插入，删除都是对数阶
> 红黑树的黑色结点个数总是和4阶B树的的结点数相等, 通过将黑色结点与它的红色子节点融合在一起，他们就具有等价性了

1. 每个结点最多有m个子树
2. 除了叶子结点和根结点外，每个结点度至少为「m/2」（「m/2」代表向上取整）
3. 如果一个结点有m个孩子，则他拥有m-1个元素/键
4. 根结点最多有m棵子树，至少有2棵子树（根结点不是非叶子结点时）
5. 所有叶子结点都在同一层次上

![](/public/btree.png)

### B+树特征 m阶

1. 如果一个结点有m个孩子，则他拥有m个元素
2. 每个元素不保存数据，只用来做索引
3. 所有叶子结点包含了全部关键字信息，及指向含有这些关键字记录的指针
4. 叶子结点的关键字依自小而大的顺序链接
5. 非叶子结点仅含有其子树结点中最大（或最小）关键字
6. 
![](/public/b+.png)

### 哈夫曼树和哈夫曼编码

结点的权：代表结点的重要性
结点的带权路径长度：结点深度*结点的权 (规定根结点的深度为0)
树的带权路径长度：WPL=>所有叶子结点的带权路径长度之和

WPL最小的二叉树就是哈夫曼树

如何构造哈夫曼树？
1. 将所有结点中最小的两个取出作为新树的左右子树（顺序不重要），同时这个新树根结点权值是左右子树之和
2. 将新的树和其余结点放在一起，再次重复步骤一的操作（如果有多种相同最小值，任选一种，因为哈夫曼树不唯一）
3. 继续重复步骤二，直到只剩下一棵树

![](/public/huffman.png)

哈夫曼编码 -> 构造哈夫曼树

哈夫曼编码是前缀编码，没有有歧义的前缀
字符集中的每一个字符作为叶子结点，字符出现的频度作为权值，构造哈夫曼树（左指针看作是0，右指针看作为1）

## 散列表

### 哈希冲突

某些情况，哈希值可能会出现相同的情况

**线性探测法**
找哈希表中相邻的位置上有没有为空的，只要哈希表没装满，那么我们肯定是可以找到位置装下这个元素的，这种类型的解决方案我们统称为线性探测法，开放定址法包含，线性探测法、平方探测法、双散列法等
线性探测法：发生了哈希冲突，那么我们就继续去找下一个空位
二次探测再散列法：它的查找增量序列为：1^2、-1^2、2^2、-2^2、...、q^2、-q^2，其中q <= (TableSize/2)
> 注：平均查找长度是指(ASL)每一个元素需要查找次数之和

**拉链法**
又称链地址法、链接法
把所有 "同义词" 存储在一个链表中

## 图

